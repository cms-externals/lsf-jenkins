# Jenkins plugin development notes

To start developing a Jenkins plugin you need to generate a simple Jenkins plugin skeleton with Maven (you need Maven and JDK installed), to do that you just need to call the command `mvn hpi:create`. A new HelloWorld example plugin will be created, you can then open it in an IDE (for example NetBeans with Jenkins Plugin and Stapler Support plugins installed) and start from there. To build the plugin run the command `mvn clean instal` and if you want to test the plugin run `mvn hpi:run -Djetty.port=8080`.

From here the main principle of writing a plugin for Jenkins is extending one of the existing classes of Jenkins, which class to extend depends on the goal of the plugin. For example, to create a new type of build step that could be added and executed by a job, you have to extend the `Builder` class. Then you have to override methods depending on what you want to do, in case of Builder you would want to override the `perform` method, in which you can put in all the actions that will be executed when a job with this build step is run. Inside the extended class you also have to extend the nested descriptor class, in this case `BuildStepDescriptor` in which you can choose a name for the build step by overriding `getDisplayName` method.

To create the configuration page for the build step or any extended Jenkins class, you have to create a `config.jelly` file for the section inside the job configuration page, or `global.jelly` file for the section inside the Jenkins global configuration page, these files have to be put inside the resources folder under the same name as the associated class.
To access the values from `config.jelly` entry fields, to you just need the `f:entry` tags in the jelly file to have the `field` values exactly the same as the parameter names of the associated class constructor (with `@DataBoundConstructor` tag). That way you can store them in the fields of the class.

To save the values from `global.jelly` entry fields you have to override the `configure` method inside the nested descriptor class and retrieve the values from the `JSONObject` with the provided methods (for example with `getString(“some_field_name”)` method) using the field values of `f:entry` tags as input. Then after you store them in the descriptor class fields, you just need to call the `save` method at the end of the `configure` method and `load` method inside the descriptor constructor.  You also need to have getters for the fields that have been saved with the same names as specified in the jelly file entry fields.

Knowing these basic concepts you just have to look at the source code of Jenkins and find the right classes to extend. It is also very useful to look at other Jenkins plugins and try to find plugins that have similarities to what you want to achieve with your plugin. Try to understand how those plugins work and try to use that in your plugin. In some cases it is even useful to just use the whole plugin you find inside your own plugin if it has exactly what you need. You can do that by including the jar file of the plugin you want to use (that can be automatically achieved in NetBeans) in your dependencies and then simply importing the class you want to use.
